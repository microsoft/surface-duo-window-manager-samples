/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License.
 */

package com.microsoft.device.wm_samples.twodo

import android.content.Intent
import android.graphics.Rect
import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.view.updatePadding
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.window.layout.DisplayFeature
import androidx.window.layout.FoldingFeature
import androidx.window.layout.WindowInfoTracker
import com.microsoft.device.wm_samples.twodo.databinding.ActivityMainBinding
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.doneButton.setOnClickListener {
            goToTwoDoActivity()
        }

        // Create a new coroutine since repeatOnLifecycle is a suspend function
        lifecycleScope.launch(Dispatchers.Main) {
            // The block passed to repeatOnLifecycle is executed when the lifecycle
            // is at least STARTED and is cancelled when the lifecycle is STOPPED.
            // It automatically restarts the block when the lifecycle is STARTED again.
            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {
                // Safely collect from windowInfoRepo when the lifecycle is STARTED
                // and stops collection when the lifecycle is STOPPED
                WindowInfoTracker.getOrCreate(this@MainActivity)
                    .windowLayoutInfo(this@MainActivity)
                    .collect { newLayoutInfo ->
                        // reset fold values
                        ConstraintLayout.getSharedValues().fireNewValue(R.id.horiz_fold, 0)
                        ConstraintLayout.getSharedValues().fireNewValue(R.id.vert_fold, 0)
                        binding.horizLogoImg.updatePadding(0, 0, 0, 0)
                        binding.logoImg.updatePadding(0, 0, 0, 0)

                        // Add views that represent display features
                        for (displayFeature in newLayoutInfo.displayFeatures) {
                            val foldFeature = displayFeature as? FoldingFeature
                            if (foldFeature != null) {
                                if (foldFeature.orientation == FoldingFeature.Orientation.HORIZONTAL) {
                                    var fold = horizontalFoldPosition(binding.root, foldFeature)
                                    ConstraintLayout.getSharedValues().fireNewValue(R.id.horiz_fold, fold)
                                    binding.horizLogoImg.updatePadding(0, foldFeature.bounds.height(), 0, 0)
                                } else {
                                    var fold = verticalFoldPosition(binding.root, foldFeature)
                                    ConstraintLayout.getSharedValues().fireNewValue(R.id.vert_fold, fold)
                                    binding.logoImg.updatePadding(foldFeature.bounds.width(), 0, 0, 0)
                                }
                            }
                        }
                    }
            }
        }
    }

    fun goToTwoDoActivity() {
        val intent = Intent(this, TwoDoActivity::class.java)
        startActivity(intent)
    }

    /**
     * Returns the position of the horizontal fold relative to the view
     */
    fun horizontalFoldPosition(view: View, foldingFeature: FoldingFeature): Int {
        val splitRect = getFeatureBoundsInWindow(foldingFeature, view)
        splitRect?.let {
            return view.height.minus(splitRect.top)
        }

        return 0
    }

    /**
     * Returns the position of the vertical fold relative to the view
     */
    fun verticalFoldPosition(view: View, foldingFeature: FoldingFeature): Int {
        val splitRect = getFeatureBoundsInWindow(foldingFeature, view)
        splitRect?.let {
            return view.width.minus(splitRect.left)
        }

        return 0
    }

    /**
     * Get the bounds of the display feature translated to the View's coordinate space and current
     * position in the window. This will also include view padding in the calculations.
     */
    fun getFeatureBoundsInWindow(
        displayFeature: DisplayFeature,
        view: View,
        includePadding: Boolean = true
    ): Rect? {
        // The the location of the view in window to be in the same coordinate space as the feature.
        val viewLocationInWindow = IntArray(2)
        view.getLocationInWindow(viewLocationInWindow)

        // Intersect the feature rectangle in window with view rectangle to clip the bounds.
        val viewRect = Rect(
            viewLocationInWindow[0], viewLocationInWindow[1],
            viewLocationInWindow[0] + view.width, viewLocationInWindow[1] + view.height
        )

        // Include padding if needed
        if (includePadding) {
            viewRect.left += view.paddingLeft
            viewRect.top += view.paddingTop
            viewRect.right -= view.paddingRight
            viewRect.bottom -= view.paddingBottom
        }

        val featureRectInView = Rect(displayFeature.bounds)
        val intersects = featureRectInView.intersect(viewRect)

        // Checks to see if the display feature overlaps with our view at all
        if ((featureRectInView.width() == 0 && featureRectInView.height() == 0) ||
            !intersects
        ) {
            return null
        }

        // Offset the feature coordinates to view coordinate space start point
        featureRectInView.offset(-viewLocationInWindow[0], -viewLocationInWindow[1])

        return featureRectInView
    }
}
